package main

import (
	"bytes"
	"encoding/json"
	"go/format"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"text/template"

	"github.com/Masterminds/semver/v3"
)

const (
	versionsOutputFile = "../protocol/generated_versions.go"
	registryOutputFile = "../protocol/generated_registry.go"
)

//goland:noinspection SpellCheckingInspection
var goNameToMcNames = map[string][]string{
	"ServerboundHandshake":           {"set_protocol"},
	"ClientboundStatusResponse":      {"server_info"},
	"ClientboundPong":                {"ping"},
	"ServerboundStatusRequest":       {"ping_start"},
	"ServerboundPing":                {"ping"},
	"ServerboundLoginStart":          {"login_start"},
	"ClientboundLoginSuccess":        {"success"},
	"ClientboundSetCompression":      {"compress"},
	"ServerboundLoginAcknowledged":   {"login_acknowledged"},
	"ClientboundKeepAlive":           {"keep_alive"},
	"ServerboundKeepAlive":           {"keep_alive"},
	"ServerboundChatMessage":         {"chat", "chat_message", "player_chat_message"},
	"ServerboundClientSettings":      {"settings", "client_information"},
	"ServerboundCustomPayload":       {"custom_payload"},
	"ClientboundCustomPayload":       {"custom_payload"},
	"ClientboundDisconnect":          {"kick_disconnect", "disconnect"},
	"ServerboundFinishConfiguration": {"finish_configuration"},
	"ClientboundFinishConfiguration": {"finish_configuration"},
	"ServerboundConfigKeepAlive":     {"keep_alive"},
	"ClientboundConfigKeepAlive":     {"keep_alive"},
	"ServerboundSelectKnownPacks":    {"select_known_packs"},
	"ClientboundSelectKnownPacks":    {"select_known_packs"},
	"ClientboundCookieRequest":       {"cookie_request"},
	"ServerboundCookieResponse":      {"cookie_response"},
	"ClientboundConfigPing":          {"ping"},
	"ServerboundConfigPong":          {"pong"},
	"ClientboundJoinGame":            {"login"},
	"ClientboundFeatureFlags":        {"feature_flags"},
	"ClientboundUpdateTags":          {"update_tags"},
	"ClientboundRegistryData":        {"registry_data"},
}

const versionsTemplate = `// Code generated by gophermc/generator. DO NOT EDIT.
// See generator/main.go for more details.
package protocol

import "fmt"

type Version int

const (
	{{- range .Versions}}
	{{.EnumName}} Version = iota
	{{- end}}
)

const First = {{.FirstVersionEnum}}
const Latest = {{.LatestVersionEnum}}

var (
	stringToVersion map[string]Version
	versionToString map[Version]string
	Versions        []Version
)

func init() {
	stringToVersion = map[string]Version{
		{{- range .Versions}}
		"{{.VersionStr}}": {{.EnumName}},
		{{- end}}
	}

	versionToString = make(map[Version]string)
	for s, v := range stringToVersion {
		versionToString[v] = s
		Versions = append(Versions, v)
	}
}

func (v Version) Protocol() int32 {
	if def := GetDefinition(v); def != nil {
		return def.ProtocolVersion
	}
	panic(fmt.Sprintf("protocol number missing for version %s", v))
}

func (v Version) String() string {
	if s, ok := versionToString[v]; ok {
		return s
	}
	return "Unknown"
}
`
const registryTemplate = `// Code generated by gophermc/generator. DO NOT EDIT.
// See generator/main.go for more details.
package protocol

// init registers all protocol definitions compiled from the JSON data.
func init() {
	{{- range .Versions}}
	protocolRegistry[{{.EnumName}}] = &Definition{
		ProtocolVersion: {{.ProtocolVersion}},
		PacketIDs:       map[State]map[Direction]map[string]int32{
			{{- range $stateName, $directions := .PacketIDs}}
			{{$stateName}}: {
				{{- range $dirName, $packets := $directions}}
				{{$dirName}}: {
					{{- range $packetName, $packetID := $packets}}
					"{{$packetName}}": {{$packetID}},
					{{- end}}
				},
				{{- end}}
			},
			{{- end}}
		},
		PacketNames: map[State]map[Direction]map[int32]string{
			{{- range $stateName, $directions := .PacketNames}}
			{{$stateName}}: {
				{{- range $dirName, $packets := $directions}}
				{{$dirName}}: {
					{{- range $packetID, $packetName := $packets}}
					{{$packetID}}: "{{$packetName}}",
					{{- end}}
				},
				{{- end}}
			},
			{{- end}}
		},
	}
	{{- end}}
}
`

type (
	mcProtocolVersion struct {
		MinecraftVersion string `json:"minecraftVersion"`
		Version          int32  `json:"version"`
	}

	mcState struct {
		ToServer mcPacketMap `json:"toServer"`
		ToClient mcPacketMap `json:"toClient"`
	}

	mcPacketMap struct {
		Types map[string]interface{} `json:"types"`
	}

	versionInfo struct {
		VersionStr      string
		EnumName        string
		ProtocolVersion int32
		PacketIDs       map[string]map[string]map[string]int32
		PacketNames     map[string]map[string]map[int32]string
	}

	templateData struct {
		Versions          []versionInfo
		LatestVersionEnum string
		FirstVersionEnum  string
	}
)

var releaseVersionRegex = regexp.MustCompile(`^\d+\.\d+(\.\d+)?$`)
var snapshotVersionRegex = regexp.MustCompile(`^\d{2}w\d{2}[a-z]$`)

func main() {
	_, currentFile, _, ok := runtime.Caller(0)
	if !ok {
		log.Fatalf("FATAL: Could not get generator's file path")
	}

	generatorDir := filepath.Dir(currentFile)
	baseDataDir := filepath.Join(generatorDir, "minecraft-data", "data", "pc")

	versionToProtoNum, latestSnapshot := loadProtocolVersions(baseDataDir)
	parsedVersions := loadAndParseProtocols(baseDataDir, versionToProtoNum, latestSnapshot)

	if len(parsedVersions) == 0 {
		log.Fatalf("FATAL: No protocol versions were successfully parsed. Check submodule path and file contents.")
	}

	sort.Slice(parsedVersions, func(i, j int) bool {
		v1, err1 := semver.NewVersion(parsedVersions[i].VersionStr)
		v2, err2 := semver.NewVersion(parsedVersions[j].VersionStr)
		if err1 == nil && err2 == nil {
			return v1.LessThan(v2)
		}
		if err1 == nil && err2 != nil {
			return true
		}
		if err1 != nil && err2 == nil {
			return false
		}
		return parsedVersions[i].ProtocolVersion < parsedVersions[j].ProtocolVersion
	})

	td := templateData{
		Versions:          parsedVersions,
		LatestVersionEnum: parsedVersions[len(parsedVersions)-1].EnumName,
		FirstVersionEnum:  parsedVersions[0].EnumName,
	}

	generateFile(versionsOutputFile, versionsTemplate, "versions", td)
	generateFile(registryOutputFile, registryTemplate, "registry", td)
}

func loadAndParseProtocols(baseDataDir string, versionToProtoNum map[string]int32, latestSnapshot string) []versionInfo {
	dirs, err := os.ReadDir(baseDataDir)
	if err != nil {
		log.Fatalf("FATAL: Failed to read submodule directory '%s'. Did you run 'git submodule update --init'?", baseDataDir)
	}

	var parsedVersions []versionInfo
	for _, dir := range dirs {
		if !dir.IsDir() {
			continue
		}
		versionStr := dir.Name()
		if !releaseVersionRegex.MatchString(versionStr) && versionStr != latestSnapshot {
			continue
		}

		protoPath := filepath.Join(baseDataDir, versionStr, "protocol.json")
		protoData, err := os.ReadFile(protoPath)
		if err != nil {
			continue
		}

		var states map[string]mcState
		if err := json.Unmarshal(protoData, &states); err != nil {
			log.Printf("WARN: Could not parse protocol.json for %s: %v", versionStr, err)
			continue
		}

		protoNum := findBestProtoNum(versionStr, versionToProtoNum)
		if protoNum == 0 {
			log.Printf("WARN: No protocol number found for version %s, skipping", versionStr)
			continue
		}

		vi := processVersion(versionStr, protoNum, states)
		parsedVersions = append(parsedVersions, vi)
	}
	return parsedVersions
}

func processVersion(versionStr string, protoNum int32, states map[string]mcState) versionInfo {
	vi := versionInfo{
		VersionStr:      versionStr,
		EnumName:        "V" + strings.ReplaceAll(versionStr, ".", "_"),
		ProtocolVersion: protoNum,
		PacketIDs:       make(map[string]map[string]map[string]int32),
		PacketNames:     make(map[string]map[string]map[int32]string),
	}

	for _, stateName := range []string{"handshaking", "status", "login", "configuration", "play"} {
		if stateData, ok := states[stateName]; ok {
			processState(stateName, stateData, &vi)
		}
	}
	return vi
}

func processState(stateName string, stateData mcState, vi *versionInfo) {
	idMapToServer := preParsePacketIDs(stateData.ToServer.Types)
	processDirection(stateName, "serverbound", idMapToServer, vi)

	idMapToClient := preParsePacketIDs(stateData.ToClient.Types)
	processDirection(stateName, "clientbound", idMapToClient, vi)
}

func processDirection(stateName, dirName string, idMap map[string]int32, vi *versionInfo) {
	if len(idMap) == 0 {
		return
	}
	title := cases.Title(language.English)

	stateEnum := "State" + title.String(stateName)
	dirEnum := "Direction" + title.String(dirName)

	for mcPacketName, id := range idMap {
		for goName, mcNames := range goNameToMcNames {
			if contains(mcNames, mcPacketName) {
				finalGoName := resolveAmbiguousNames(goName, stateName, dirName)
				if finalGoName == "" {
					continue
				}

				if vi.PacketIDs[stateEnum] == nil {
					vi.PacketIDs[stateEnum] = make(map[string]map[string]int32)
					vi.PacketNames[stateEnum] = make(map[string]map[int32]string)
				}

				if vi.PacketIDs[stateEnum][dirEnum] == nil {
					vi.PacketIDs[stateEnum][dirEnum] = make(map[string]int32)
					vi.PacketNames[stateEnum][dirEnum] = make(map[int32]string)
				}

				vi.PacketIDs[stateEnum][dirEnum][finalGoName] = id
				vi.PacketNames[stateEnum][dirEnum][id] = finalGoName
				break
			}
		}
	}
}

func preParsePacketIDs(packetTypes map[string]interface{}) map[string]int32 {
	idMap := make(map[string]int32)
	if packetTypes == nil {
		return idMap
	}

	packetContainer, ok := packetTypes["packet"].([]interface{})
	if !ok || len(packetContainer) < 2 {
		return idMap
	}
	fields, ok := packetContainer[1].([]interface{})
	if !ok {
		return idMap
	}

	for _, field := range fields {
		fieldMap, ok := field.(map[string]interface{})
		if !ok || fieldMap["name"] != "name" {
			continue
		}

		typeArr, ok := fieldMap["type"].([]interface{})
		if !ok || len(typeArr) < 2 || typeArr[0] != "mapper" {
			continue
		}

		meta, ok := typeArr[1].(map[string]interface{})
		if !ok {
			continue
		}
		mappings, ok := meta["mappings"].(map[string]interface{})
		if !ok {
			continue
		}

		for idHex, name := range mappings {
			if nameStr, ok := name.(string); ok {
				id, _ := strconv.ParseInt(strings.TrimPrefix(idHex, "0x"), 16, 32)
				idMap[nameStr] = int32(id)
			}
		}
		return idMap
	}
	return idMap
}

func loadProtocolVersions(baseDataDir string) (map[string]int32, string) {
	versionsPath := filepath.Join(baseDataDir, "common", "protocolVersions.json")
	versionData, err := os.ReadFile(versionsPath)
	if err != nil {
		log.Fatalf("FATAL: Failed to read %s: %v", versionsPath, err)
	}
	var versionList []mcProtocolVersion
	if err := json.Unmarshal(versionData, &versionList); err != nil {
		log.Fatalf("FATAL: Failed to parse %s: %v", versionsPath, err)
	}
	versionToProtoNum := make(map[string]int32)
	var latestSnapshot string
	var latestSnapshotProto int32
	for _, v := range versionList {
		versionToProtoNum[v.MinecraftVersion] = v.Version
		if snapshotVersionRegex.MatchString(v.MinecraftVersion) && v.Version > latestSnapshotProto {
			latestSnapshotProto = v.Version
			latestSnapshot = v.MinecraftVersion
		}
	}
	return versionToProtoNum, latestSnapshot
}

func findBestProtoNum(versionStr string, versionMap map[string]int32) int32 {
	if p, ok := versionMap[versionStr]; ok {
		return p
	}
	for v, p := range versionMap {
		if strings.HasPrefix(v, versionStr) {
			return p
		}
	}
	return 0
}

func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

//goland:noinspection SpellCheckingInspection
func resolveAmbiguousNames(goName, stateName, dirName string) string {
	switch goName {
	case "ClientboundDisconnect":
		if stateName == "login" {
			return "ClientboundDisconnect"
		}
		return "ClientboundDisconnect"
	case "ServerboundCustomPayload", "ClientboundCustomPayload":
		if dirName == "serverbound" {
			return "ServerboundCustomPayload"
		}
		return "ClientboundCustomPayload"
	case "ServerboundSelectKnownPacks", "ClientboundSelectKnownPacks":
		if dirName == "serverbound" {
			return "ServerboundSelectKnownPacks"
		}
		return "ClientboundSelectKnownPacks"
	case "ServerboundFinishConfiguration", "ClientboundFinishConfiguration":
		if stateName != "configuration" {
			return ""
		}
		if dirName == "serverbound" {
			return "ServerboundFinishConfiguration"
		}
		return "ClientboundFinishConfiguration"
	case "ClientboundKeepAlive", "ServerboundKeepAlive", "ServerboundConfigKeepAlive", "ClientboundConfigKeepAlive":
		if dirName == "serverbound" {
			if stateName == "configuration" {
				return "ServerboundConfigKeepAlive"
			}
			return "ServerboundKeepAlive"
		}
		if stateName == "configuration" {
			return "ClientboundConfigKeepAlive"
		}
		return "ClientboundKeepAlive"
	case "ClientboundPong", "ServerboundPing", "ClientboundConfigPing", "ServerboundConfigPong":
		if dirName == "clientbound" {
			if stateName == "configuration" {
				return "ClientboundConfigPing"
			}
			return "ClientboundPong"
		}
		if stateName == "status" {
			return "ServerboundPing"
		}
		if stateName == "configuration" {
			return "ServerboundConfigPong"
		}
		return ""
	default:
		return goName
	}
}

func generateFile(path, tmplString, tmplName string, data templateData) {
	tmpl, err := template.New(tmplName).Parse(tmplString)
	if err != nil {
		log.Fatalf("FATAL: Failed to parse %s template: %v", tmplName, err)
	}
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		log.Fatalf("FATAL: Failed to execute %s template: %v", tmplName, err)
	}
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("FATAL: Failed to format generated %s code: %v\n---\n%s", tmplName, err, buf.String())
	}
	if err := os.WriteFile(path, formatted, 0644); err != nil {
		log.Fatalf("FATAL: Failed to write %s output file: %v", tmplName, err)
	}

}
